2023-08-21 12:41:59:453 grammar LogManager.java:25 before: (LEXER_GRAMMAR SwiftLexer (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE TSTRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHAR (BLOCK (ALT 'Character'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE TRU (BLOCK (ALT 'true'))) (RULE FAL (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE ISEMPTY (BLOCK (ALT 'IsEmpty'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE REPEATING (BLOCK (ALT 'repeating'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER (BLOCK (ALT '"' (? (BLOCK (ALT (~ (SET [']))))) '"'))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE IG (BLOCK (ALT '='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MOD (BLOCK (ALT '%'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE CORIZQ (BLOCK (ALT '['))) (RULE CORDER (BLOCK (ALT ']'))) (RULE DOSP (BLOCK (ALT ':'))) (RULE COMA (BLOCK (ALT ','))) (RULE INTCE (BLOCK (ALT '?'))) (RULE FLECHA (BLOCK (ALT '->'))) (RULE AMP (BLOCK (ALT '&'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip)))))
2023-08-21 12:41:59:478 grammar LogManager.java:25 after: (LEXER_GRAMMAR SwiftLexer (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE TSTRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHAR (BLOCK (ALT 'Character'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE TRU (BLOCK (ALT 'true'))) (RULE FAL (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE ISEMPTY (BLOCK (ALT 'IsEmpty'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE REPEATING (BLOCK (ALT 'repeating'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER (BLOCK (ALT '"' (? (BLOCK (ALT (~ (SET [']))))) '"'))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE IG (BLOCK (ALT '='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MOD (BLOCK (ALT '%'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE CORIZQ (BLOCK (ALT '['))) (RULE CORDER (BLOCK (ALT ']'))) (RULE DOSP (BLOCK (ALT ':'))) (RULE COMA (BLOCK (ALT ','))) (RULE INTCE (BLOCK (ALT '?'))) (RULE FLECHA (BLOCK (ALT '->'))) (RULE AMP (BLOCK (ALT '&'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip)))))
2023-08-21 12:42:00:053 grammar LogManager.java:25 before: (COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Backend/interfaces"
    import "Backend/environment"
    import "Backend/expressions"
    import "Backend/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { }))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE ifstmt (BLOCK (ALT IF PARIZQ expr PARDER LLAVEIZQ block LLAVEDER))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (BLOCK (ALT MUL) (ALT DIV) (ALT MOD))) (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT ADD) (ALT SUB))) (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MAY_IG) (ALT MAYOR))) (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MEN_IG) (ALT MENOR))) (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT IG_IG) (ALT DIF))) (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) AND (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) OR (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= op NOT) (= left expr) { $e = expressions.NewOperationUnary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT CHAR {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.CHAR)
    }) (ALT ID {
        
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) })))))
2023-08-21 12:42:00:057 grammar LogManager.java:25 after: (COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Backend/interfaces"
    import "Backend/environment"
    import "Backend/expressions"
    import "Backend/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { }))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE ifstmt (BLOCK (ALT IF PARIZQ expr PARDER LLAVEIZQ block LLAVEDER))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV MOD)) (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB)) (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) AND (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) OR (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= op NOT) (= left expr) { $e = expressions.NewOperationUnary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT CHAR {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.CHAR)
    }) (ALT ID {
        
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) })))))
2023-08-21 12:42:00:057 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Backend/interfaces"
    import "Backend/environment"
    import "Backend/expressions"
    import "Backend/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { }))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE ifstmt (BLOCK (ALT IF PARIZQ expr PARDER LLAVEIZQ block LLAVEDER))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV MOD)) (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB)) (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) AND (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) OR (= right expr) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= op NOT) (= left expr) { $e = expressions.NewOperationUnary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT CHAR {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.CHAR)
    }) (ALT ID {
        
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) })))))
2023-08-21 12:42:00:057 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR SwiftGrammarLexer OPTIONS (@ header {
    import "Backend/interfaces"
    import "Backend/environment"
    import "Backend/expressions"
    import "Backend/instructions"
    import "strings"
}) RULES)
2023-08-21 12:42:00:081 left-recursion LogManager.java:25 expr returns [interfaces.Expression e]
    :   ( {} op=NOT<tokenIndex=260> left=expr<tokenIndex=264,p=8>  { $e = expressions.NewOperationUnary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text) } 
        | PARIZQ<tokenIndex=270> expr<tokenIndex=272> PARDER<tokenIndex=274> { $e = $expr.e } 
        | NUMBER<tokenIndex=280>                             
    {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    } 
        | STRING<tokenIndex=286>
    {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    } 
        | CHAR<tokenIndex=292>
    {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.CHAR)
    } 
        | ID<tokenIndex=298>
    {
        
    } 
        | TRU<tokenIndex=304> { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) } 
        | FAL<tokenIndex=310> { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 15)}?<p=15> op=(MUL<tokenIndex=135>|DIV<tokenIndex=137>|MOD<tokenIndex=139>) right=expr<tokenIndex=144,p=16> { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 14)}?<p=14> op=(ADD<tokenIndex=157>|SUB<tokenIndex=159>) right=expr<tokenIndex=164,p=15> { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 13)}?<p=13> op=(MAY_IG<tokenIndex=177>|MAYOR<tokenIndex=179>) right=expr<tokenIndex=184,p=14> { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 12)}?<p=12> op=(MEN_IG<tokenIndex=197>|MENOR<tokenIndex=199>) right=expr<tokenIndex=204,p=13> { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 11)}?<p=11> op=(IG_IG<tokenIndex=217>|DIF<tokenIndex=219>) right=expr<tokenIndex=224,p=12> { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 10)}?<p=10> AND<tokenIndex=234> right=expr<tokenIndex=238,p=11> { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 9)}?<p=9> OR<tokenIndex=248> right=expr<tokenIndex=252,p=10> { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
        )*
    ;
2023-08-21 12:42:00:105 grammar LogManager.java:25 added: (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (BLOCK (ALT {} (= op (NOT (ELEMENT_OPTIONS (= tokenIndex 260)))) (= left (expr (ELEMENT_OPTIONS (= tokenIndex 264) (= p 8)))) { $e = expressions.NewOperationUnary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text) }) (ALT (PARIZQ (ELEMENT_OPTIONS (= tokenIndex 270))) (expr (ELEMENT_OPTIONS (= tokenIndex 272))) (PARDER (ELEMENT_OPTIONS (= tokenIndex 274))) { $e = $expr.e }) (ALT (NUMBER (ELEMENT_OPTIONS (= tokenIndex 280))) {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT (STRING (ELEMENT_OPTIONS (= tokenIndex 286))) {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT (CHAR (ELEMENT_OPTIONS (= tokenIndex 292))) {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.CHAR)
    }) (ALT (ID (ELEMENT_OPTIONS (= tokenIndex 298))) {
        
    }) (ALT (TRU (ELEMENT_OPTIONS (= tokenIndex 304))) { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT (FAL (ELEMENT_OPTIONS (= tokenIndex 310))) { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 15)}? (ELEMENT_OPTIONS (= p 15))) (= op (SET (MUL (ELEMENT_OPTIONS (= tokenIndex 135))) (DIV (ELEMENT_OPTIONS (= tokenIndex 137))) (MOD (ELEMENT_OPTIONS (= tokenIndex 139))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 144) (= p 16)))) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 14)}? (ELEMENT_OPTIONS (= p 14))) (= op (SET (ADD (ELEMENT_OPTIONS (= tokenIndex 157))) (SUB (ELEMENT_OPTIONS (= tokenIndex 159))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 164) (= p 15)))) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 13)}? (ELEMENT_OPTIONS (= p 13))) (= op (SET (MAY_IG (ELEMENT_OPTIONS (= tokenIndex 177))) (MAYOR (ELEMENT_OPTIONS (= tokenIndex 179))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 184) (= p 14)))) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 12)}? (ELEMENT_OPTIONS (= p 12))) (= op (SET (MEN_IG (ELEMENT_OPTIONS (= tokenIndex 197))) (MENOR (ELEMENT_OPTIONS (= tokenIndex 199))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 204) (= p 13)))) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 11)}? (ELEMENT_OPTIONS (= p 11))) (= op (SET (IG_IG (ELEMENT_OPTIONS (= tokenIndex 217))) (DIF (ELEMENT_OPTIONS (= tokenIndex 219))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 224) (= p 12)))) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 10)}? (ELEMENT_OPTIONS (= p 10))) (AND (ELEMENT_OPTIONS (= tokenIndex 234))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 238) (= p 11)))) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 9)}? (ELEMENT_OPTIONS (= p 9))) (OR (ELEMENT_OPTIONS (= tokenIndex 248))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 252) (= p 10)))) { $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }))))))
2023-08-21 12:42:00:117 grammar LogManager.java:25 import INT=1
2023-08-21 12:42:00:117 grammar LogManager.java:25 import FLOAT=2
2023-08-21 12:42:00:117 grammar LogManager.java:25 import TSTRING=3
2023-08-21 12:42:00:118 grammar LogManager.java:25 import BOOL=4
2023-08-21 12:42:00:118 grammar LogManager.java:25 import CHAR=5
2023-08-21 12:42:00:118 grammar LogManager.java:25 import VAR=6
2023-08-21 12:42:00:118 grammar LogManager.java:25 import LET=7
2023-08-21 12:42:00:118 grammar LogManager.java:25 import TRU=8
2023-08-21 12:42:00:118 grammar LogManager.java:25 import FAL=9
2023-08-21 12:42:00:118 grammar LogManager.java:25 import PRINT=10
2023-08-21 12:42:00:118 grammar LogManager.java:25 import IF=11
2023-08-21 12:42:00:118 grammar LogManager.java:25 import ELSE=12
2023-08-21 12:42:00:118 grammar LogManager.java:25 import SWITCH=13
2023-08-21 12:42:00:118 grammar LogManager.java:25 import CASE=14
2023-08-21 12:42:00:118 grammar LogManager.java:25 import DEFAULT=15
2023-08-21 12:42:00:118 grammar LogManager.java:25 import BREAK=16
2023-08-21 12:42:00:118 grammar LogManager.java:25 import CONTINUE=17
2023-08-21 12:42:00:118 grammar LogManager.java:25 import RETURN=18
2023-08-21 12:42:00:118 grammar LogManager.java:25 import WHILE=19
2023-08-21 12:42:00:118 grammar LogManager.java:25 import FOR=20
2023-08-21 12:42:00:118 grammar LogManager.java:25 import IN=21
2023-08-21 12:42:00:118 grammar LogManager.java:25 import GUARD=22
2023-08-21 12:42:00:118 grammar LogManager.java:25 import APPEND=23
2023-08-21 12:42:00:118 grammar LogManager.java:25 import REMOVELAST=24
2023-08-21 12:42:00:118 grammar LogManager.java:25 import REMOVE=25
2023-08-21 12:42:00:118 grammar LogManager.java:25 import ISEMPTY=26
2023-08-21 12:42:00:118 grammar LogManager.java:25 import COUNT=27
2023-08-21 12:42:00:118 grammar LogManager.java:25 import REPEATING=28
2023-08-21 12:42:00:118 grammar LogManager.java:25 import STRUCT=29
2023-08-21 12:42:00:118 grammar LogManager.java:25 import SELF=30
2023-08-21 12:42:00:118 grammar LogManager.java:25 import MUTATING=31
2023-08-21 12:42:00:118 grammar LogManager.java:25 import FUNC=32
2023-08-21 12:42:00:118 grammar LogManager.java:25 import NUMBER=33
2023-08-21 12:42:00:118 grammar LogManager.java:25 import STRING=34
2023-08-21 12:42:00:121 grammar LogManager.java:25 import ID=35
2023-08-21 12:42:00:121 grammar LogManager.java:25 import CHARACTER=36
2023-08-21 12:42:00:121 grammar LogManager.java:25 import DIF=37
2023-08-21 12:42:00:121 grammar LogManager.java:25 import IG_IG=38
2023-08-21 12:42:00:121 grammar LogManager.java:25 import NOT=39
2023-08-21 12:42:00:121 grammar LogManager.java:25 import OR=40
2023-08-21 12:42:00:121 grammar LogManager.java:25 import AND=41
2023-08-21 12:42:00:121 grammar LogManager.java:25 import IG=42
2023-08-21 12:42:00:121 grammar LogManager.java:25 import MAY_IG=43
2023-08-21 12:42:00:121 grammar LogManager.java:25 import MEN_IG=44
2023-08-21 12:42:00:121 grammar LogManager.java:25 import MAYOR=45
2023-08-21 12:42:00:121 grammar LogManager.java:25 import MENOR=46
2023-08-21 12:42:00:121 grammar LogManager.java:25 import MOD=47
2023-08-21 12:42:00:121 grammar LogManager.java:25 import MUL=48
2023-08-21 12:42:00:121 grammar LogManager.java:25 import DIV=49
2023-08-21 12:42:00:125 grammar LogManager.java:25 import ADD=50
2023-08-21 12:42:00:125 grammar LogManager.java:25 import SUB=51
2023-08-21 12:42:00:125 grammar LogManager.java:25 import PARIZQ=52
2023-08-21 12:42:00:125 grammar LogManager.java:25 import PARDER=53
2023-08-21 12:42:00:125 grammar LogManager.java:25 import LLAVEIZQ=54
2023-08-21 12:42:00:125 grammar LogManager.java:25 import LLAVEDER=55
2023-08-21 12:42:00:125 grammar LogManager.java:25 import CORIZQ=56
2023-08-21 12:42:00:125 grammar LogManager.java:25 import CORDER=57
2023-08-21 12:42:00:125 grammar LogManager.java:25 import DOSP=58
2023-08-21 12:42:00:125 grammar LogManager.java:25 import COMA=59
2023-08-21 12:42:00:125 grammar LogManager.java:25 import INTCE=60
2023-08-21 12:42:00:125 grammar LogManager.java:25 import FLECHA=61
2023-08-21 12:42:00:125 grammar LogManager.java:25 import AMP=62
2023-08-21 12:42:00:125 grammar LogManager.java:25 import WHITESPACE=63
2023-08-21 12:42:00:125 grammar LogManager.java:25 import COMMENT=64
2023-08-21 12:42:00:125 grammar LogManager.java:25 import LINE_COMMENT=65
2023-08-21 12:42:00:125 grammar LogManager.java:25 import 'Int'=1
2023-08-21 12:42:00:125 grammar LogManager.java:25 import 'Float'=2
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'String'=3
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'Bool'=4
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'Character'=5
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'var'=6
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'let'=7
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'true'=8
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'false'=9
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'print'=10
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'if'=11
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'else'=12
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'switch'=13
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'case'=14
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'default'=15
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'break'=16
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'continue'=17
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'return'=18
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'while'=19
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'for'=20
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'in'=21
2023-08-21 12:42:00:127 grammar LogManager.java:25 import 'guard'=22
2023-08-21 12:42:00:129 grammar LogManager.java:25 import 'append'=23
2023-08-21 12:42:00:129 grammar LogManager.java:25 import 'removeLast'=24
2023-08-21 12:42:00:129 grammar LogManager.java:25 import 'remove'=25
2023-08-21 12:42:00:129 grammar LogManager.java:25 import 'IsEmpty'=26
2023-08-21 12:42:00:129 grammar LogManager.java:25 import 'count'=27
2023-08-21 12:42:00:129 grammar LogManager.java:25 import 'repeating'=28
2023-08-21 12:42:00:129 grammar LogManager.java:25 import 'struct'=29
2023-08-21 12:42:00:129 grammar LogManager.java:25 import 'self'=30
2023-08-21 12:42:00:129 grammar LogManager.java:25 import 'mutating'=31
2023-08-21 12:42:00:129 grammar LogManager.java:25 import 'func'=32
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '!='=37
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '=='=38
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '!'=39
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '||'=40
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '&&'=41
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '='=42
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '>='=43
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '<='=44
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '>'=45
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '<'=46
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '%'=47
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '*'=48
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '/'=49
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '+'=50
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '-'=51
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '('=52
2023-08-21 12:42:00:129 grammar LogManager.java:25 import ')'=53
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '{'=54
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '}'=55
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '['=56
2023-08-21 12:42:00:129 grammar LogManager.java:25 import ']'=57
2023-08-21 12:42:00:129 grammar LogManager.java:25 import ':'=58
2023-08-21 12:42:00:129 grammar LogManager.java:25 import ','=59
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '?'=60
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '->'=61
2023-08-21 12:42:00:129 grammar LogManager.java:25 import '&'=62
2023-08-21 12:42:00:129 grammar LogManager.java:25 tokens={INT=1, FLOAT=2, TSTRING=3, BOOL=4, CHAR=5, VAR=6, LET=7, TRU=8, FAL=9, PRINT=10, IF=11, ELSE=12, SWITCH=13, CASE=14, DEFAULT=15, BREAK=16, CONTINUE=17, RETURN=18, WHILE=19, FOR=20, IN=21, GUARD=22, APPEND=23, REMOVELAST=24, REMOVE=25, ISEMPTY=26, COUNT=27, REPEATING=28, STRUCT=29, SELF=30, MUTATING=31, FUNC=32, NUMBER=33, STRING=34, ID=35, CHARACTER=36, DIF=37, IG_IG=38, NOT=39, OR=40, AND=41, IG=42, MAY_IG=43, MEN_IG=44, MAYOR=45, MENOR=46, MOD=47, MUL=48, DIV=49, ADD=50, SUB=51, PARIZQ=52, PARDER=53, LLAVEIZQ=54, LLAVEDER=55, CORIZQ=56, CORDER=57, DOSP=58, COMA=59, INTCE=60, FLECHA=61, AMP=62, WHITESPACE=63, COMMENT=64, LINE_COMMENT=65, 'Int'=1, 'Float'=2, 'String'=3, 'Bool'=4, 'Character'=5, 'var'=6, 'let'=7, 'true'=8, 'false'=9, 'print'=10, 'if'=11, 'else'=12, 'switch'=13, 'case'=14, 'default'=15, 'break'=16, 'continue'=17, 'return'=18, 'while'=19, 'for'=20, 'in'=21, 'guard'=22, 'append'=23, 'removeLast'=24, 'remove'=25, 'IsEmpty'=26, 'count'=27, 'repeating'=28, 'struct'=29, 'self'=30, 'mutating'=31, 'func'=32, '!='=37, '=='=38, '!'=39, '||'=40, '&&'=41, '='=42, '>='=43, '<='=44, '>'=45, '<'=46, '%'=47, '*'=48, '/'=49, '+'=50, '-'=51, '('=52, ')'=53, '{'=54, '}'=55, '['=56, ']'=57, ':'=58, ','=59, '?'=60, '->'=61, '&'=62}
2023-08-21 12:42:00:129 semantics LogManager.java:25 tokens={EOF=-1, INT=1, FLOAT=2, TSTRING=3, BOOL=4, CHAR=5, VAR=6, LET=7, TRU=8, FAL=9, PRINT=10, IF=11, ELSE=12, SWITCH=13, CASE=14, DEFAULT=15, BREAK=16, CONTINUE=17, RETURN=18, WHILE=19, FOR=20, IN=21, GUARD=22, APPEND=23, REMOVELAST=24, REMOVE=25, ISEMPTY=26, COUNT=27, REPEATING=28, STRUCT=29, SELF=30, MUTATING=31, FUNC=32, NUMBER=33, STRING=34, ID=35, CHARACTER=36, DIF=37, IG_IG=38, NOT=39, OR=40, AND=41, IG=42, MAY_IG=43, MEN_IG=44, MAYOR=45, MENOR=46, MOD=47, MUL=48, DIV=49, ADD=50, SUB=51, PARIZQ=52, PARDER=53, LLAVEIZQ=54, LLAVEDER=55, CORIZQ=56, CORDER=57, DOSP=58, COMA=59, INTCE=60, FLECHA=61, AMP=62, WHITESPACE=63, COMMENT=64, LINE_COMMENT=65}
2023-08-21 12:42:00:129 semantics LogManager.java:25 strings={'Int'=1, 'Float'=2, 'String'=3, 'Bool'=4, 'Character'=5, 'var'=6, 'let'=7, 'true'=8, 'false'=9, 'print'=10, 'if'=11, 'else'=12, 'switch'=13, 'case'=14, 'default'=15, 'break'=16, 'continue'=17, 'return'=18, 'while'=19, 'for'=20, 'in'=21, 'guard'=22, 'append'=23, 'removeLast'=24, 'remove'=25, 'IsEmpty'=26, 'count'=27, 'repeating'=28, 'struct'=29, 'self'=30, 'mutating'=31, 'func'=32, '!='=37, '=='=38, '!'=39, '||'=40, '&&'=41, '='=42, '>='=43, '<='=44, '>'=45, '<'=46, '%'=47, '*'=48, '/'=49, '+'=50, '-'=51, '('=52, ')'=53, '{'=54, '}'=55, '['=56, ']'=57, ':'=58, ','=59, '?'=60, '->'=61, '&'=62}
2023-08-21 12:42:00:165 LL1 LogManager.java:25 
DECISION 0 in rule block
2023-08-21 12:42:00:165 LL1 LogManager.java:25 look=[{10..11}, {<EOF>, 55}]
2023-08-21 12:42:00:165 LL1 LogManager.java:25 LL(1)? true
2023-08-21 12:42:00:165 LL1 LogManager.java:25 
DECISION 1 in rule instruction
2023-08-21 12:42:00:165 LL1 LogManager.java:25 look=[10, 11]
2023-08-21 12:42:00:165 LL1 LogManager.java:25 LL(1)? true
2023-08-21 12:42:00:165 LL1 LogManager.java:25 
DECISION 2 in rule expr
2023-08-21 12:42:00:165 LL1 LogManager.java:25 look=[39, 52, 33, 34, 5, 35, 8, 9]
2023-08-21 12:42:00:165 LL1 LogManager.java:25 LL(1)? true
2023-08-21 12:42:00:165 LL1 LogManager.java:25 
DECISION 3 in rule expr
2023-08-21 12:42:00:165 LL1 LogManager.java:25 look=[null, null, null, null, null, null, null]
2023-08-21 12:42:00:165 LL1 LogManager.java:25 LL(1)? false
2023-08-21 12:42:00:165 LL1 LogManager.java:25 
DECISION 4 in rule expr
2023-08-21 12:42:00:167 LL1 LogManager.java:25 look=[null, null]
2023-08-21 12:42:00:167 LL1 LogManager.java:25 LL(1)? false
2023-08-21 12:42:00:169 action-translator LogManager.java:25 translate 
    import "Backend/interfaces"
    import "Backend/environment"
    import "Backend/expressions"
    import "Backend/instructions"
    import "strings"

2023-08-21 12:42:00:182 action-translator LogManager.java:25 translate    
        $code = $block.blk
    
2023-08-21 12:42:00:185 action-translator LogManager.java:25 attr [@-1,14:17='code',<0>,20:9]
2023-08-21 12:42:00:187 action-translator LogManager.java:25 qattr [@-1,22:26='block',<0>,20:17].[@-1,28:30='blk',<0>,20:23]
2023-08-21 12:42:00:190 action-translator LogManager.java:25 translate 
    $blk = []interface{}{}
    var listInt []IInstructionContext
  
2023-08-21 12:42:00:190 action-translator LogManager.java:25 attr [@-1,7:9='blk',<0>,26:5]
2023-08-21 12:42:00:194 action-translator LogManager.java:25 translate 
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    
2023-08-21 12:42:00:194 action-translator LogManager.java:25 attr [@-1,105:107='blk',<0>,33:13]
2023-08-21 12:42:00:194 action-translator LogManager.java:25 attr [@-1,119:121='blk',<0>,33:27]
2023-08-21 12:42:00:194 action-translator LogManager.java:25 translate  $inst = $printstmt.prnt
2023-08-21 12:42:00:194 action-translator LogManager.java:25 attr [@-1,2:5='inst',<0>,39:14]
2023-08-21 12:42:00:194 action-translator LogManager.java:25 qattr [@-1,10:18='printstmt',<0>,39:22].[@-1,20:23='prnt',<0>,39:32]
2023-08-21 12:42:00:197 action-translator LogManager.java:25 translate  
2023-08-21 12:42:00:198 action-translator LogManager.java:25 translate  $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)
2023-08-21 12:42:00:198 action-translator LogManager.java:25 attr [@-1,2:5='prnt',<0>,44:29]
2023-08-21 12:42:00:198 action-translator LogManager.java:25 qattr [@-1,32:36='PRINT',<0>,44:59].[@-1,38:41='line',<0>,44:65]
2023-08-21 12:42:00:198 action-translator LogManager.java:25 qattr [@-1,44:48='PRINT',<0>,44:71].[@-1,50:52='pos',<0>,44:77]
2023-08-21 12:42:00:198 action-translator LogManager.java:25 qattr [@-1,55:58='expr',<0>,44:82].[@-1,60:60='e',<0>,44:87]
2023-08-21 12:42:00:202 action-translator LogManager.java:25 translate 
2023-08-21 12:42:00:202 action-translator LogManager.java:25 translate  $e = expressions.NewOperationUnary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text) 
2023-08-21 12:42:00:202 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,2:69]
2023-08-21 12:42:00:202 action-translator LogManager.java:25 qattr [@-1,37:40='left',<0>,2:104].[@-1,42:46='start',<0>,2:109]
2023-08-21 12:42:00:202 action-translator LogManager.java:25 qattr [@-1,60:63='left',<0>,2:127].[@-1,65:69='start',<0>,2:132]
2023-08-21 12:42:00:202 action-translator LogManager.java:25 qattr [@-1,85:88='left',<0>,2:152].[@-1,90:90='e',<0>,2:157]
2023-08-21 12:42:00:202 action-translator LogManager.java:25 qattr [@-1,94:95='op',<0>,2:161].[@-1,97:100='text',<0>,2:164]
2023-08-21 12:42:00:206 action-translator LogManager.java:25 translate  $e = $expr.e 
2023-08-21 12:42:00:207 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,3:79]
2023-08-21 12:42:00:207 action-translator LogManager.java:25 qattr [@-1,7:10='expr',<0>,3:84].[@-1,12:12='e',<0>,3:89]
2023-08-21 12:42:00:207 action-translator LogManager.java:25 translate 
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    
2023-08-21 12:42:00:207 action-translator LogManager.java:25 qattr [@-1,32:37='NUMBER',<0>,6:30].[@-1,39:42='text',<0>,6:37]
2023-08-21 12:42:00:207 action-translator LogManager.java:25 qattr [@-1,95:100='NUMBER',<0>,7:43].[@-1,102:105='text',<0>,7:50]
2023-08-21 12:42:00:207 action-translator LogManager.java:25 attr [@-1,203:203='e',<0>,11:13]
2023-08-21 12:42:00:207 action-translator LogManager.java:25 qattr [@-1,233:238='NUMBER',<0>,11:43].[@-1,240:243='line',<0>,11:50]
2023-08-21 12:42:00:207 action-translator LogManager.java:25 qattr [@-1,246:251='NUMBER',<0>,11:56].[@-1,253:255='pos',<0>,11:63]
2023-08-21 12:42:00:207 action-translator LogManager.java:25 qattr [@-1,334:339='NUMBER',<0>,13:37].[@-1,341:344='text',<0>,13:44]
2023-08-21 12:42:00:210 action-translator LogManager.java:25 attr [@-1,437:437='e',<0>,17:13]
2023-08-21 12:42:00:210 action-translator LogManager.java:25 qattr [@-1,467:472='NUMBER',<0>,17:43].[@-1,474:477='line',<0>,17:50]
2023-08-21 12:42:00:210 action-translator LogManager.java:25 qattr [@-1,480:485='NUMBER',<0>,17:56].[@-1,487:489='pos',<0>,17:63]
2023-08-21 12:42:00:210 action-translator LogManager.java:25 translate 
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    
2023-08-21 12:42:00:210 action-translator LogManager.java:25 qattr [@-1,18:23='STRING',<0>,22:16].[@-1,25:28='text',<0>,22:23]
2023-08-21 12:42:00:210 action-translator LogManager.java:25 attr [@-1,40:40='e',<0>,23:9]
2023-08-21 12:42:00:210 action-translator LogManager.java:25 qattr [@-1,70:75='STRING',<0>,23:39].[@-1,77:80='line',<0>,23:46]
2023-08-21 12:42:00:214 action-translator LogManager.java:25 qattr [@-1,84:89='STRING',<0>,23:53].[@-1,91:93='pos',<0>,23:60]
2023-08-21 12:42:00:214 action-translator LogManager.java:25 translate 
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.CHAR)
    
2023-08-21 12:42:00:214 action-translator LogManager.java:25 qattr [@-1,18:23='STRING',<0>,27:16].[@-1,25:28='text',<0>,27:23]
2023-08-21 12:42:00:214 action-translator LogManager.java:25 attr [@-1,40:40='e',<0>,28:9]
2023-08-21 12:42:00:214 action-translator LogManager.java:25 qattr [@-1,70:75='STRING',<0>,28:39].[@-1,77:80='line',<0>,28:46]
2023-08-21 12:42:00:214 action-translator LogManager.java:25 qattr [@-1,84:89='STRING',<0>,28:53].[@-1,91:93='pos',<0>,28:60]
2023-08-21 12:42:00:217 action-translator LogManager.java:25 translate 
        
    
2023-08-21 12:42:00:217 action-translator LogManager.java:25 translate  $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) 
2023-08-21 12:42:00:218 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,34:32]
2023-08-21 12:42:00:218 action-translator LogManager.java:25 qattr [@-1,32:34='TRU',<0>,34:62].[@-1,36:39='line',<0>,34:66]
2023-08-21 12:42:00:218 action-translator LogManager.java:25 qattr [@-1,43:45='TRU',<0>,34:73].[@-1,47:49='pos',<0>,34:77]
2023-08-21 12:42:00:218 action-translator LogManager.java:25 translate  $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) 
2023-08-21 12:42:00:218 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,35:32]
2023-08-21 12:42:00:218 action-translator LogManager.java:25 qattr [@-1,32:34='FAL',<0>,35:62].[@-1,36:39='line',<0>,35:66]
2023-08-21 12:42:00:218 action-translator LogManager.java:25 qattr [@-1,43:45='FAL',<0>,35:73].[@-1,47:49='pos',<0>,35:77]
2023-08-21 12:42:00:218 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 15)
2023-08-21 12:42:00:222 action-translator LogManager.java:25 translate  $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) 
2023-08-21 12:42:00:222 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,38:159]
2023-08-21 12:42:00:222 action-translator LogManager.java:25 qattr [@-1,38:41='left',<0>,38:195].[@-1,43:47='start',<0>,38:200]
2023-08-21 12:42:00:222 action-translator LogManager.java:25 qattr [@-1,61:64='left',<0>,38:218].[@-1,66:70='start',<0>,38:223]
2023-08-21 12:42:00:222 action-translator LogManager.java:25 qattr [@-1,86:89='left',<0>,38:243].[@-1,91:91='e',<0>,38:248]
2023-08-21 12:42:00:222 action-translator LogManager.java:25 qattr [@-1,95:96='op',<0>,38:252].[@-1,98:101='text',<0>,38:255]
2023-08-21 12:42:00:222 action-translator LogManager.java:25 qattr [@-1,105:109='right',<0>,38:262].[@-1,111:111='e',<0>,38:268]
2023-08-21 12:42:00:222 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 14)
2023-08-21 12:42:00:222 action-translator LogManager.java:25 translate  $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) 
2023-08-21 12:42:00:222 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,39:149]
2023-08-21 12:42:00:222 action-translator LogManager.java:25 qattr [@-1,38:41='left',<0>,39:185].[@-1,43:47='start',<0>,39:190]
2023-08-21 12:42:00:222 action-translator LogManager.java:25 qattr [@-1,61:64='left',<0>,39:208].[@-1,66:70='start',<0>,39:213]
2023-08-21 12:42:00:222 action-translator LogManager.java:25 qattr [@-1,86:89='left',<0>,39:233].[@-1,91:91='e',<0>,39:238]
2023-08-21 12:42:00:222 action-translator LogManager.java:25 qattr [@-1,95:96='op',<0>,39:242].[@-1,98:101='text',<0>,39:245]
2023-08-21 12:42:00:222 action-translator LogManager.java:25 qattr [@-1,105:109='right',<0>,39:252].[@-1,111:111='e',<0>,39:258]
2023-08-21 12:42:00:222 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 13)
2023-08-21 12:42:00:222 action-translator LogManager.java:25 translate  $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) 
2023-08-21 12:42:00:222 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,40:154]
2023-08-21 12:42:00:222 action-translator LogManager.java:25 qattr [@-1,38:41='left',<0>,40:190].[@-1,43:47='start',<0>,40:195]
2023-08-21 12:42:00:227 action-translator LogManager.java:25 qattr [@-1,61:64='left',<0>,40:213].[@-1,66:70='start',<0>,40:218]
2023-08-21 12:42:00:227 action-translator LogManager.java:25 qattr [@-1,86:89='left',<0>,40:238].[@-1,91:91='e',<0>,40:243]
2023-08-21 12:42:00:227 action-translator LogManager.java:25 qattr [@-1,95:96='op',<0>,40:247].[@-1,98:101='text',<0>,40:250]
2023-08-21 12:42:00:227 action-translator LogManager.java:25 qattr [@-1,105:109='right',<0>,40:257].[@-1,111:111='e',<0>,40:263]
2023-08-21 12:42:00:227 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 12)
2023-08-21 12:42:00:227 action-translator LogManager.java:25 translate  $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) 
2023-08-21 12:42:00:227 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,41:154]
2023-08-21 12:42:00:227 action-translator LogManager.java:25 qattr [@-1,38:41='left',<0>,41:190].[@-1,43:47='start',<0>,41:195]
2023-08-21 12:42:00:227 action-translator LogManager.java:25 qattr [@-1,61:64='left',<0>,41:213].[@-1,66:70='start',<0>,41:218]
2023-08-21 12:42:00:227 action-translator LogManager.java:25 qattr [@-1,86:89='left',<0>,41:238].[@-1,91:91='e',<0>,41:243]
2023-08-21 12:42:00:227 action-translator LogManager.java:25 qattr [@-1,95:96='op',<0>,41:247].[@-1,98:101='text',<0>,41:250]
2023-08-21 12:42:00:231 action-translator LogManager.java:25 qattr [@-1,105:109='right',<0>,41:257].[@-1,111:111='e',<0>,41:263]
2023-08-21 12:42:00:231 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 11)
2023-08-21 12:42:00:231 action-translator LogManager.java:25 translate  $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) 
2023-08-21 12:42:00:231 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,42:151]
2023-08-21 12:42:00:231 action-translator LogManager.java:25 qattr [@-1,38:41='left',<0>,42:187].[@-1,43:47='start',<0>,42:192]
2023-08-21 12:42:00:231 action-translator LogManager.java:25 qattr [@-1,61:64='left',<0>,42:210].[@-1,66:70='start',<0>,42:215]
2023-08-21 12:42:00:231 action-translator LogManager.java:25 qattr [@-1,86:89='left',<0>,42:235].[@-1,91:91='e',<0>,42:240]
2023-08-21 12:42:00:235 action-translator LogManager.java:25 qattr [@-1,95:96='op',<0>,42:244].[@-1,98:101='text',<0>,42:247]
2023-08-21 12:42:00:235 action-translator LogManager.java:25 qattr [@-1,105:109='right',<0>,42:254].[@-1,111:111='e',<0>,42:260]
2023-08-21 12:42:00:235 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 10)
2023-08-21 12:42:00:235 action-translator LogManager.java:25 translate  $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) 
2023-08-21 12:42:00:235 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,43:124]
2023-08-21 12:42:00:237 action-translator LogManager.java:25 qattr [@-1,38:41='left',<0>,43:160].[@-1,43:47='start',<0>,43:165]
2023-08-21 12:42:00:237 action-translator LogManager.java:25 qattr [@-1,61:64='left',<0>,43:183].[@-1,66:70='start',<0>,43:188]
2023-08-21 12:42:00:237 action-translator LogManager.java:25 qattr [@-1,86:89='left',<0>,43:208].[@-1,91:91='e',<0>,43:213]
2023-08-21 12:42:00:238 action-translator LogManager.java:25 qattr [@-1,95:96='op',<0>,43:217].[@-1,98:101='text',<0>,43:220]
2023-08-21 12:42:00:238 action-translator LogManager.java:25 qattr [@-1,105:109='right',<0>,43:227].[@-1,111:111='e',<0>,43:233]
2023-08-21 12:42:00:239 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 9)
2023-08-21 12:42:00:240 action-translator LogManager.java:25 translate  $e = expressions.NewOperationBinary($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) 
2023-08-21 12:42:00:240 action-translator LogManager.java:25 attr [@-1,2:2='e',<0>,44:121]
2023-08-21 12:42:00:240 action-translator LogManager.java:25 qattr [@-1,38:41='left',<0>,44:157].[@-1,43:47='start',<0>,44:162]
2023-08-21 12:42:00:240 action-translator LogManager.java:25 qattr [@-1,61:64='left',<0>,44:180].[@-1,66:70='start',<0>,44:185]
2023-08-21 12:42:00:240 action-translator LogManager.java:25 qattr [@-1,86:89='left',<0>,44:205].[@-1,91:91='e',<0>,44:210]
2023-08-21 12:42:00:240 action-translator LogManager.java:25 qattr [@-1,95:96='op',<0>,44:214].[@-1,98:101='text',<0>,44:217]
2023-08-21 12:42:00:240 action-translator LogManager.java:25 qattr [@-1,105:109='right',<0>,44:224].[@-1,111:111='e',<0>,44:230]
2023-08-21 12:42:00:243 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 15)
2023-08-21 12:42:00:243 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 14)
2023-08-21 12:42:00:243 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 13)
2023-08-21 12:42:00:243 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 12)
2023-08-21 12:42:00:243 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 11)
2023-08-21 12:42:00:243 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 10)
2023-08-21 12:42:00:243 action-translator LogManager.java:25 translate p.Precpred(p.GetParserRuleContext(), 9)
2023-08-21 12:42:00:439 action-translator LogManager.java:25 translate 
    import "Backend/interfaces"
    import "Backend/environment"
    import "Backend/expressions"
    import "Backend/instructions"
    import "strings"

2023-08-21 12:42:00:439 action-translator LogManager.java:25 translate 
    import "Backend/interfaces"
    import "Backend/environment"
    import "Backend/expressions"
    import "Backend/instructions"
    import "strings"

2023-08-21 12:42:00:527 action-translator LogManager.java:25 translate 
    import "Backend/interfaces"
    import "Backend/environment"
    import "Backend/expressions"
    import "Backend/instructions"
    import "strings"

2023-08-21 12:42:00:527 action-translator LogManager.java:25 translate 
    import "Backend/interfaces"
    import "Backend/environment"
    import "Backend/expressions"
    import "Backend/instructions"
    import "strings"

